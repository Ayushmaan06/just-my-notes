# Работа с макросами, скриптами и триггерами в Google Sheets

Google Apps Script - это платформа для быстрой разработки приложений, позволяющая быстро и легко создавать бизнес-приложения, интегрируемые с G Suite. Вы пишете код на JavaScript и имеете доступ к встроенным библиотекам для любимых приложений G Suite, таких как Gmail, Календарь, Диск и многое другое. Google предоставляет нам редактор кода прямо в нашем браузере, и ваши скрипты запускаются на серверах Google.

## Макросы

Макрос - некоторая последовательность действий пользователя прикладной программы, которая записана в виде отдельной процедуры (фрагмент кода) и может выполнятся автоматически как одна программа.

Макросы предназначены для автоматизации процессов работы с документами: если пользователь считает, что он выполняет много однообразных действий (копирование, вставка и т.д.) раз за разом, то он может записать эти действия в один макрос и вызывать его, например, при нажатии комбинации клавиш когда будет нужно.

> macro - в ед. числе

> macros - во мн. числе

В Google Sheet с макросами можно делать такие вещи:
 
 - запись: Tools -> Macros -> Record Macro.
 - управление (переименовать, назначить клавиши, удалить): Tools -> Macros -> Manage.
 - импорт - если есть функция в скрипте, где лежат уже импортированные макросы, и её тоже хочется использовать как макрос, то нужно импортировать её таким образом: Tools -> Macros -> Import.

 > Импортировать макросы можно из каких-угодно мест: текущего проекта привязанного к документу, другого проекта привязанного к документу и стороннего проекта.

В Google Sheet в последствии создания макросов создается скрипт macros.gs.

## Скрипты

В отличии от макроса скрипт, как правило, является более формально-определенным с хорошо-определенным скриптованным языков, стоящим у него за спиной. Это именно, что код, который будет подаваться интерпретатору на выполнение (интерпретироваться - выполняться построчно).

> Главное отличие скрипта от программы состоит в том, что скрипт интерпретируется (is interpreted), а программа испольняется (is executed).

В случае Google Sheets скриптом может являться файл содержащий макросы (они представляются функциями JavaScript). Так же он может содержать от руки написанные макросы, которые чтобы использовать нужно сначало импортировать так, как было описано в предыдущем параграфе.

Чтобы редактировать скрипты нужно открыть Tools -> Script Editor. Если не было создано скриптов (например, в последствии создания макросов), то будет предложено создать новый проект, иначе откроется уже созданный файл.

Скрипты вкладываются в проекты. Например, в моем "Recorded Macros (Schedule)" находится два скрипта, в которых находятся различные макросы. А вот проекты, похоже, что вкладываются в контейнеры (container). Например, у меня проект "Recorded Macros (Schedule)" вкладывается в контейнер Schedule - таблицу, где и выполняются эти макросы. Рядом можно еще проектов сделать для своих целей.

Если проектов несколько, то после открытия Tools -> Script Editor нужно будет выбрать конкретный проект.

## Триггеры

Triggers позволяют Apps Script запускать функцию автоматически, когда происходит определенное событие, например, открытие документа. Простые триггеры - это набор зарезервированных функций, встроенных в Apps Script, таких как функция onOpen(e), которая выполняется, когда пользователь открывает документы, листы, слайды или файлы форм Google. Installable triggers обладают большими возможностями, чем простые триггеры, но должны быть активированы перед использованием. Для обоих типов триггеров Apps Script передает запущенную функцию объекту события, который содержит информацию о контексте, в котором произошло событие.

Параметр e в названии функции выше - это объект события, передаваемый функции. Объект содержит информацию о контексте, приведшем к возгоранию триггера, но его использование является необязательным.

## Проблемы, с которыми я столкнулся при работе с Google Sheets

### Проблема с привелегиями у собственной функции при вызове openByID

Задача была сделать так, чтобы обновление таблицы Schedule происходило не когда она открыта в определенное время (в соответствии с time-driven triggers), а независимо. Я нашел вариант решения, в котором оказалось что нужно создавать другой проект. Проблема была в функции, которая не хотела через ID получать доступ к документу. Однако, оказалось, что у функции из стороннего проекта привелелий на доступ к документу через ID гораздо больше чем у местной. А смешно это потому, что своя кастомная функция не может получить доступ через ID к своему же документу :D

> If your function is a custom function, that is one which can be used like a regular spreadsheet function in the sheet itself, then it has limited access to things and cannot open other spreadsheets.

Метод openByID может вызываться из нового Пустого Проекта ("Blank Project"), но не из своих собственных функций ("Custom Functions in Sheets", например в файле создания макросов) и не из проектов-аддонов ("Google Sheets Add-on" project).

Если создавать новый проект из вкладки "Script Editor", то мы получим как раз "Blank Project", который кстати будет привязан к нашему документу. Однако я заметил, что openByID может вызываться даже если новый проект не будет привязан к документу. Я создал тестовый проект и поместил в местный скрипт такую функцию:

```js
function myF() {
  var ss = SpreadsheetApp.openById("id"); // id is the id of the spreadsheet
  // https://docs.google.com/spreadsheets/d/id_is_here/
  var sh = ss.getSheetByName("Schedule"); // name of the actual sheet ("Sheet 1" for example)
  sh.getRange('B1:H33').activate();
  sh.getActiveRangeList().setFontColor('#2395ff');
}
```

После этого надо дать доступ макросу на выполнение его задачи через процедуру авторизации Google. После этого можно создавать соответствующий time-driven trigger.

### Проблема с ожиданием при выборе time-driven триггера

Если поставить триггер на активацию в течении какого-либо часа, то сама активация может произойти в первые 5 минут, а то и в последние 5 минут часа. Иногда это зависит от количества триггеров.

Некоторые пишут, что для того чтобы активация была мгновенной нужно проапгрейдить G Suite.

Однако мгновенной активация будет если поставить таймер на каждую минуту.

Активация в течении часа всё-равно должна произойти, даже если это будет в начале следующего часа. Если активация в течении часа не происходит и при этом нет ошибок, то значит этот триггер уже срабатывал в этом часу благодаря изменениям пользователя. Например, пользователь что-то тестировал и система уже провела активацию триггера. Похоже, что больше одного раза система не будет его активировать.

### Проблема модификации диапазона данных на основе выбора произвольных строк этого же диапазона

Задача: убрать из Schedule определенное количество строк при невыполнении заданного количества заданий. То есть, сделать так, чтобы при невыполнении n заданий дня из раздела с развлечениями убиралось соответственно n объектов - penalty.

Для начало нужно создать диалоговое меню с помощью App Script, этакий диалог-подсказку (Dialog Prompt), где пользователь мог бы ввести номер дня недели чтобы вычислить насколько хорошо он поработал в указанный день и заслуживает ли он отдых. Пользователь может ввести число от 1 до 6, не включая 7. 7 соответсвует Sunday, в конце которого просто не зачем уже оценивать потенциальный отдых - конец недели всё-таки. Диалоговое окно можно задать таким образом:

```js
function showPromptForDeletingCertainAmountOfRowsArbitrarily() {
  var ui = SpreadsheetApp.getUi(); // Same variations.
  var result = ui.prompt(
      'Please enter a number of a day of a week.',
      'Number of a day from 1 to 6 (not including Sunday)',
      ui.ButtonSet.OK_CANCEL);
  // Process the user's response.
  var button = result.getSelectedButton();
  var day = result.getResponseText();
  if (button == ui.Button.OK) {
    // User clicked "OK".
    DeleteCertainAmountOfRowsArbitrarily(day);
  }
}
```
Именну эту функцию выше стоит импортировать в качестве макроса и назначить ей комбинацию клавиш.

Дальше нужно прописать саму логику. В следующей функции выполняется задача:

```js
function DeleteCertainAmountOfRowsArbitrarily(day) {
  var activeSheet = SpreadsheetApp.getActiveSheet();
  var amount_of_rows_to_delete = 0;
  switch(day) {
  case "1":
    amount_of_rows_to_delete = activeSheet.getRange('B56:H56').getValue();
    break;
  case "2":
    amount_of_rows_to_delete = activeSheet.getRange('C56:H56').getValue();
    break;
  case "3":
    amount_of_rows_to_delete = activeSheet.getRange('D56:H56').getValue();
    break;
  case "4":
    amount_of_rows_to_delete = activeSheet.getRange('E56:H56').getValue();
    break;
  case "5":
    amount_of_rows_to_delete = activeSheet.getRange('F56:H56').getValue();
    break;
  case "6":
    amount_of_rows_to_delete = activeSheet.getRange('G56:H56').getValue();
    break;
  default:
    var ui = SpreadsheetApp.getUi();
    var result = ui.alert(
     'You entered wrong number of day. The number must be from 1 to 6.');
  }
  // randomize range to not exclude same items
  activeSheet.getRange('L3:M41').activate().randomize();
  for (var i = 41; i > 2 && amount_of_rows_to_delete > 0; i--) {
    var r = activeSheet.getRange('L'+i+':M'+i);
    if(!r.isBlank())
    {
      // clear format and delete info of a cell
      r.clearFormat().clear({contentsOnly: true, skipFilteredRows: true});
      amount_of_rows_to_delete--;
    }
  }
  // sort "Games" and "TV shows" columns
  activeSheet.getRange('L3:L41').activate()
  .sort({column: 12, ascending: true});
  activeSheet.getRange('M3:M41').activate()
  .sort({column: 13, ascending: true});
};
```

Посидев на StackOverflow я пришел к выводу, что проще будет обрабатывать диапазон в цикле меняя счетчик, который будет указывать номер строки функции getRange. А сам счетчик лучше инициализировать числом 41, которое обозначает последнюю строку диапазон (вероятно, это стоит задать программно). Таким образом, программа делает это:

1. Сначала происходит рандомизация диапазона, чтобы не удалять одни и те же элементы раз за разом, а оставлять хоть какое-то разнообразие.
2. Потом удаляются строки пока, соответственно, счетчик количества невыполненых предметов не обратится в 0.
3. И затем происходит сортировка диапазона отдельно по столбцам. Это возвращает порядок пользователю и так он сможет лучше понять какие развлекательные наименования остались в списке. 